int mod(string s,int n)
{
    int r=0;
    for(int i=0;i<s.length();i++)
    {
        r=r*10+(s[i]-'0');
        r=r%n;
    }
    return r;
}
bool printbt(ll n,ll bt)    //print value of bit x  ,, return bool  (0,1)
{
    return (n>>bt)&1;
}
int changBtTo1(ll n,ll bt)  //change bit x to 1
{
    return n|(1<<bt);
}
int changBtTo0(ll n,ll bt)  //change bit x to 0
{
    return n& ~(1<<bt);
}


int changBtTo0(ll n,ll bt)  //change bit x to 0
{
    return n^(1<<bt);
}
ll flip(ll n,ll bt)   // flip bit x  
{
    return n^(1<<bt);
}
int turnOnLastZero(int n)
{
    return n|(n+1);
}
int turnOffLastOne(int n)
{
    return n&(n-1);
}
int turnOnFLastConsecutiveZeroes(int n)   // change all bits from (index 0 until first                  
{                                                                        //   bit equal to 1 ) to 1
    return n|(n-1);
}
int turnOffLastConsecutiveOnes(int n)  //   change all bits from (index 0 until first
{                                                                     // equal to 0)  to 0
    return n&(n+1);
}
bool isPowerOfTwo(int n)   // check if n is power of two or not 
{                                                //    n must be greater than zero 
    return (n&(n-1))==0;
}
bool check_bit(int n,int bt)  
{
    return (n&(1ll<<bt));
}
int cntBits(int mask)   // O(bits length)
{
    int cnt=0;
    while(mask)
    {
        if(mask&1)cnt++;
        mask>>=1;
    }
    return cnt;
}
cout<<__builtin_popcount(n);      // count number of ones

cout<<__builtin_popcountll(n);




ll countAllBits(ll n)  
{
    int cnt=0;
    while(n)
    {
        cnt++; n>>=1;
    }
    return cnt;
}
ll cntallbits(ll n)
{
    return log2(n)+1;
}



Prime factorization
vector<int>a; int n;cin>>n;
 for(int i = 2;i*i<=n;i++) {
        while(n%i==0)
        {
            a.push_back(i);
            n/=i;
        }
 } if(n!=1)a.push_back(n);
   for(int i:a)cout<<i<<" ";
   




String = ‘accd’  -> ‘ac’ , ‘cd’
int sum = 0,mx = 0;
for(auto &i:f){
    sum+=i;
    mx =max(mx,i);
}
cout<<max(mx,(sum+1)/2);

or

multiset<int>st;
for (int i = 0; i < 26; ++i) {
    if(f[i])st.insert(f[i]);
}
int ans = 0;
while (st.size() > 1){
    int mn = *st.begin();
    int mx = *st.rbegin();
    st.erase(st.find(mn));
    st.erase(st.find(mx));
    ans++;

    if(mx - 1)st.insert(mx - 1);
    if(mn - 1)st.insert(mn - 1);
}
if(!st.empty())ans += *st.begin();
cout << ans << endl;







•  struct segTree{
•      vector<int>seg;
•      int sz;
•   
•      void build(int ind,int lo,int hi,int n,vector<int>&a){
•          if(hi-lo == 1)
•          {
•              seg[ind] = ( lo < n ? a[lo] : INT_MAX);
•              return;
•          }
•          int mid = (lo + hi)/2;
•          build(2*ind+1,lo,mid,n,a);
•          build(2*ind+2,mid,hi,n,a);
•          seg[ind] = seg[2*ind+1] & seg[2*ind+2];
•      }
•   
•      segTree(int n,vector<int> &a)
•      {
•              sz = 1 ;
•              while (sz < n)sz *= 2;
•              seg = vector<int>(sz*2);
•              build(0,0,sz,n,a);
•      }
•      int query(int ind,int low,int high,int l,int r)
•      {
•          if(low >= l && r >= high)return seg[ind];
•          if(l>=high || low >= r)return INT_MAX;
•          int mid = (low + high) /2;
•          int left = query(2*ind+1,low,mid,l,r);
•          int right = query(2*ind+2,mid,high,l,r);
•          return (left&right);
•      }
•      int get(int l,int r)
•      {
•          return query(0,0,sz,l-1,r);
•      }
•   
•  };
•   
•   





•  void out() {
•      int n;cin>>n;
•      vector<int>a(n);
•      for (int i = 0; i < n; ++i) {
•          cin>>a[i];
•      }
•      segTree sol(n,a);
•   
•      int q;cin>>q;
•      while(q--) {
•          int start, k;
•          cin >> start >> k;
•          int l = start,r = n;
•          int ans = -1;
•          while(r>=l)
•          {
•              int mid = (l+r)/2;
•              int x = sol.get(start,mid);
•              if(x>=k)
•              {
•                  l = mid+1;
•                  ans = mid;
•              }
•              else{
•                  r = mid-1;
•              }
•          }
•          cout <<ans<<" ";
•      }
•   
•  }




int find_first_less_than(int x){
    int l = 0,r = m-1;
    int ans = -1;
    while(r>=l){
        int m = l + (r-l) / 2;
        if(b[m] <= x){
            ans = m;
            l = m+1;
        }
        else{
            r = m-1;
        }
    }
    return ans;
}




int find_first_greater_than(int x){
    int l = 0,r = m-1;
    int ans = -1;
    while(r>=l){
        int m = l + (r-l) / 2;
        if(b[m] >= x){
            ans = m;
            r = m-1;
        }
        else{
            l = m+1;
        }
    }
    return ans;
}


Sieve 

vector<bool>primes(1e6+5,1);
    int siz = 1e6;
    primes[0] = 0;
    primes[1] = 0;
    for (int i = 2; i*i <= siz ; ++i) {
        if(primes[i])
        {
            for (int j = i*i; j <= siz; j+=i) {
                primes[j] = 0;
            }
        }
    }
    for (int i = 0; i < 30; ++i) {
        cout<<i<<" " << primes[i]<<"\n";
    }


- To find Lexicographically largest sub-sequence of the given string
traverse the string from left to right 
  take the leftmost largest character for remaining suffix
string "adcdab"   select d
string "cdab"   select d
string "ab"  select b
so the ans will be "ddb"


